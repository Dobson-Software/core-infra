name: Deploy Cobalt Platform (Dev)

on:
  push:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      image_tag_override:
        description: "Override image tag (leave empty to use git SHA)"
        required: false
        type: string

env:
  AWS_REGION: us-east-1

permissions:
  id-token: write
  contents: read

# Dev-only deployment workflow.
# Production deployments use the promote.yml Blue/Green pipeline.

jobs:
  # ---------------------------------------------------------------------------
  # Determine target environment (always dev)
  # ---------------------------------------------------------------------------
  setup:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      image_tag: ${{ steps.tag.outputs.tag }}
    steps:
      - name: Determine environment
        id: env
        run: |
          # All automated deploys go to dev. Prod uses the promote workflow.
          echo "environment=dev" >> "$GITHUB_OUTPUT"

      - name: Set image tag
        id: tag
        run: |
          if [ -n "${{ inputs.image_tag_override }}" ]; then
            echo "tag=${{ inputs.image_tag_override }}" >> "$GITHUB_OUTPUT"
          else
            echo "tag=sha-${GITHUB_SHA::8}" >> "$GITHUB_OUTPUT"
          fi

  # ---------------------------------------------------------------------------
  # Build and push Docker images to ECR
  # ---------------------------------------------------------------------------
  build-and-push:
    runs-on: ubuntu-latest
    needs: setup
    environment: ${{ needs.setup.outputs.environment }}
    strategy:
      matrix:
        service:
          - name: core-service
            context: ./backend
            dockerfile: ./backend/Dockerfile.core
          - name: notification-service
            context: ./backend
            dockerfile: ./backend/Dockerfile.notification
          - name: violations-service
            context: ./backend
            dockerfile: ./backend/Dockerfile.violations
          - name: frontend
            context: ./frontend
            dockerfile: ./frontend/Dockerfile
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          IMAGE_TAG: ${{ needs.setup.outputs.image_tag }}
          SERVICE_NAME: ${{ matrix.service.name }}
        run: |
          IMAGE_URI="${ECR_REGISTRY}/cobalt/${SERVICE_NAME}:${IMAGE_TAG}"
          IMAGE_DEV="${ECR_REGISTRY}/cobalt/${SERVICE_NAME}:dev"

          docker build \
            -t "${IMAGE_URI}" \
            -t "${IMAGE_DEV}" \
            -f "${{ matrix.service.dockerfile }}" \
            "${{ matrix.service.context }}"

          docker push "${IMAGE_URI}"
          docker push "${IMAGE_DEV}"

          echo "Pushed ${IMAGE_URI}"
          echo "Pushed ${IMAGE_DEV}"

  # ---------------------------------------------------------------------------
  # Deploy to Kubernetes
  # ---------------------------------------------------------------------------
  deploy:
    runs-on: ubuntu-latest
    needs: [setup, build-and-push]
    environment: ${{ needs.setup.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: ecr-login
        uses: aws-actions/amazon-ecr-login@v2

      - name: Configure kubectl
        env:
          ENVIRONMENT: ${{ needs.setup.outputs.environment }}
        run: |
          aws eks update-kubeconfig \
            --name "cobalt-${ENVIRONMENT}" \
            --region "${{ env.AWS_REGION }}"

      - name: Apply K8s base manifests
        run: |
          kubectl apply -f infrastructure/terraform/k8s/base/
          kubectl apply -f infrastructure/terraform/k8s/services/
          kubectl apply -f infrastructure/terraform/k8s/ingress/

      - name: Deploy monitoring stack
        run: |
          kubectl apply -f infrastructure/terraform/k8s/monitoring/

      - name: Update deployments with new image
        env:
          ECR_REGISTRY: ${{ steps.ecr-login.outputs.registry }}
          IMAGE_TAG: ${{ needs.setup.outputs.image_tag }}
        run: |
          SERVICES=("core-service:8080" "notification-service:8081" "violations-service:8082" "frontend:80")

          for entry in "${SERVICES[@]}"; do
            SERVICE="${entry%%:*}"
            IMAGE_URI="${ECR_REGISTRY}/cobalt/${SERVICE}:${IMAGE_TAG}"

            echo "Updating ${SERVICE} to ${IMAGE_URI}"

            kubectl set image deployment/"${SERVICE}" \
              "${SERVICE}=${IMAGE_URI}" \
              -n cobalt-services
          done

      - name: Wait for rollouts
        run: |
          for SERVICE in core-service notification-service violations-service frontend; do
            echo "Waiting for ${SERVICE} rollout..."
            kubectl rollout status deployment/"${SERVICE}" \
              -n cobalt-services \
              --timeout=300s
          done

      - name: Smoke test health endpoints
        run: |
          DOMAIN="dev.cobaltplatform.com"

          ENDPOINTS=(
            "https://${DOMAIN}/actuator/health"
          )

          FAILED=0
          for ENDPOINT in "${ENDPOINTS[@]}"; do
            echo "Testing ${ENDPOINT}..."
            for i in $(seq 1 5); do
              HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "${ENDPOINT}" 2>/dev/null)
              if [ "${HTTP_STATUS}" = "200" ]; then
                echo "OK: ${ENDPOINT} returned 200"
                break
              fi
              echo "Attempt ${i}/5: ${ENDPOINT} returned ${HTTP_STATUS}, retrying in 10s..."
              sleep 10
            done

            if [ "${HTTP_STATUS}" != "200" ]; then
              echo "FAIL: ${ENDPOINT} returned ${HTTP_STATUS}"
              FAILED=1
            fi
          done

          if [ "${FAILED}" = "1" ]; then
            echo "Smoke tests failed"
            exit 1
          fi

  # ---------------------------------------------------------------------------
  # Rollback on failure
  # ---------------------------------------------------------------------------
  rollback:
    runs-on: ubuntu-latest
    needs: [setup, deploy]
    if: failure()
    environment: ${{ needs.setup.outputs.environment }}
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl
        env:
          ENVIRONMENT: ${{ needs.setup.outputs.environment }}
        run: |
          aws eks update-kubeconfig \
            --name "cobalt-${ENVIRONMENT}" \
            --region "${{ env.AWS_REGION }}"

      - name: Rollback deployments
        run: |
          echo "Deploy failed â€” rolling back all services"

          for SERVICE in core-service notification-service violations-service frontend; do
            echo "Rolling back ${SERVICE}..."
            kubectl rollout undo deployment/"${SERVICE}" \
              -n cobalt-services || true
          done

      - name: Wait for rollback completion
        run: |
          for SERVICE in core-service notification-service violations-service frontend; do
            echo "Waiting for ${SERVICE} rollback..."
            kubectl rollout status deployment/"${SERVICE}" \
              -n cobalt-services \
              --timeout=300s || true
          done

          echo "Rollback complete"
